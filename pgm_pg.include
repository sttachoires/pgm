#! /bin/bash
# 
# Bash library for PostgreSQL.
#
# S. Tachoires		10/11/2014	Initial version
#
#set -xv

# INCLUDE
if [ "${PGM_PG_INCLUDE}" == "LOADED" ]; then
  return 0
fi
. /home/stephane/postgres/github/pgm/pgm_server.include
. /home/stephane/postgres/github/pgm/pgm_util.include

# CONSTANTS
# The starting point of every instance directory
export PGM_PGBASE_DIR="/home/stephane/postgres/pgdb"
# List of allowed charater (form of a regular expression) alowed to form instances name
export PGM_PGSID_AUTHORIZED_CHARS="-a-zA-Z._#0-9"
# List of allowed charater (form of a regular expression) alowed to form databases name
export PGM_PGDATABASE_AUTHORIZED_CHARS="-a-zA-Z._#0-9"
export PGM_PGEXTENTIONS="adminpack, auto_explain, pg_stat_statements, postgres_fdw, sslinfo, btree_gin, btree_gist"
export PGM_PGEXTENTIONS_TO_CREATE="adminpack pg_stat_statements postgres_fdw sslinfo btree_gin btree_gist"
export PGM_PGLOG_FILE="postgresql.log"


# Pattern for different constants 
# Pattern PGMPGPATTERN_NAME will be expanded into PGM_NAME
# In those pattern you can use, in addition to the previous PGM_ constants above and those of includes above:
#  ${PGM_FULL_VERSION} that contains full text version of a PostgreSQL server (9.5.0)
#  ${PGM_FULL_VERSION_NUM} that contains full numeric version (950)
#  ${PGM_MAJOR_VERSION} the major text version (9.5)
#  ${PGM_MAJOR_VERSION_NUM} the major numeric version (95)
#  ${PGM_PGSID} the instance name
PGMPGPATTERN_PGDATA='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/data'
PGMPGPATTERN_PGLOG='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/log'
PGMPGPATTERN_PGXLOG='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/xlog/wal'
PGMPGPATTERN_PGARCHIVELOG='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/archivelog'
PGMPGPATTERN_PGDBBASE='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}'
#PGMPGPATTERN_PGFSLIST='"${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID} ${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/xlog ${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/archivelog ${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/log"'
PGMPGPATTERN_PGFSLIST=''
PGMPGPATTERN_PGRECOVER='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/data/recovery.conf.bak'
PGMPGPATTERN_PGCONF='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/data/postgresql.conf'
PGMPGPATTERN_PGHBA='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/data/pg_hba.conf'
PGMPGPATTERN_PGIDENT='${PGM_PGBASE_DIR}/${PGM_MAJOR_VERSION}/${PGM_PGSID}/data/pg_ident.conf'

function pgExec()
{
  if [ $# -gt 1 ]; then
    dbname=$1
    request=$2
  else
    request=$1
  fi
  if [ ! -x ${PGM_PGHOME}/bin/psql ]; then
    printError "Problem with '${PGM_PGHOME}/bin/psql'"
  fi

  ${PGM_PGHOME}/bin/psql --host=${PGM_PGDATA} --port=${PGM_PGPORT} --tuples-only -v ON_ERROR_STOP=1 ${dbname} -c "${request}"
}

function startInstance()
{
  if [ $# -ne 2 ]; then
    return 1
  fi
  pgm_version=$1
  pgm_sid=$2
  setInstance ${pgm_version} ${pgm_sid}

  pgm_options=""
  ping -c 1 ${PGM_PGLISTENER} 2>&1 > /dev/null
  if [ $? -ne 0 ]; then
    pgm_options="${pgm_options} -h ${PGM_PGHOST}"
  fi

  pg_ctl -o "${pgm_options}" --pgdata=${PGM_PGDATA} --log=${PGM_PGLOG}/${PGM_PGLOG_FILE} start
  sleep 10
}

function stopInstance()
{
  if [ $# -ne 2 ]; then
    return 1
  fi
  pgm_version=$1
  pgm_sid=$2
  setInstance ${pgm_version} ${pgm_sid}

  pg_ctl --pgdata=${PGM_PGDATA} --mode=fast stop
}

function setInstance()
{
  if [ $# -ne 2 ]; then
    return 1
  fi

  pgm_version=$1
  pgm_sid=$2
  
  setServer ${pgm_version}
  if [ $? -ne 0 ]; then
    return 2
  fi

  if [[ ${pgm_sid} =~ [${PGM_PGSID_AUTHORIZED_CHARS}]+ ]]; then
    # First set versions constants
    export PGM_PGSID=${pgm_sid}

    # Remove trailing slashes.
    PGM_PGBASE_DIR=${PGM_PGBASE_DIR%/}
    for pgm_pattern in ${!PGMPGPATTERN_*}
    do
      eval pgm_value=\$${pgm_pattern}
      eval export ${pgm_pattern/PGMPGPATTERN_/PGM_}=${pgm_value%/}
    done

    # Try to determine host, port, autolaunch configuration, and running configuration
    export PGM_PGHOST=$(uname --nodename)
    pgm_line=$(egrep "^[[:space:]]*listen_addresses[[:space:]]*=" ${PGM_PGCONF} 2>&1)
    if [ $? -eq 0 ]; then
      export PGM_PGLISTENER="$(echo ${pgm_line} | cut --delimiter='=' --fields=2)"
    fi
    PGM_PGHOST=${PGM_PGHOST// /}
    PGM_PGLISTENER=${PGM_PGLISTENER// /}
    PGM_PGLISTENER=${PGM_PGLISTENER:=${PGM_PGHOST}}

    pgm_line=$(egrep "^[[:space:]]*port[[:space:]]*=" ${PGM_PGCONF} 2>&1)
    if [ $? -eq 0 ]; then
      export PGM_PGPORT="$(echo ${pgm_line} | cut --delimiter='=' --fields=2)"
    else
      export PGM_PGPORT=5432
    fi
    PGM_PGPORT=${PGM_PGPORT// /}

    pgm_processes=$(ps -afe | egrep "-D[[:space:]][[:space:]]*${PGM_PGDATA}[[:space:]]" 2>&1)
    if [ $? -eq 0 ]; then
      export PGM_PGSTATUS="started"
      pgm_hostline=$(echo ${pgm_processes} | grep -o "[[:space:]][[:space:]]*-h[[:space:]][[:space:]]*[^[:space:]][^[:space:]]*[[:space:]]")
      if [ $? -eq 0 ]; then
        pgm_hostline=${pgm_hostline/ -h /}
        export PGM_PGREALHOST=${pgm_hostline// /}
      fi
      pgm_portline=$(echo ${pgm_processes} | grep -o "[[:space:]][[:space:]]*-p[[:space:]][[:space:]]*[0-9][0-9]*[[:space:]]")
      if [ $? -eq 0 ]; then
        pgm_portline=${pgm_portline/ -p /}
        export PGM_PGREALPORT=${pgm_portline// /}
      fi
    else
      export PGM_PGSTATUS="stopped"
    fi

    pgm_line=$(egrep "^\*:${PGM_PGSID}:${PGM_PGVERSION}:[ynYN]" ${PGM_PGTAB} | head -1)
    if [ $? -eq 0 ]; then
      pgm_autolaunch=$(echo "${pgm_line}" | cut --delimiter=':' --fields=3)
      pgm_autolaunch=${pgm_line:0:1}
      export PGM_PGAUTOLAUNCH=${pgm_autolaunch,,}
    fi
    return 0
  else
    printf "Wrong instance name \"${pgm_sid}\"\n"
    return 3
  fi

}

function setDatabase()
{
  if [ $# -ne 3 ]; then
    return 1
  else
    pgm_version=$1
    pgm_sid=$2
    pgm_database=$3  
  fi


  setInstance ${pgm_version} ${pgm_sid}
  if [ $? -ne 0 ]; then
    return 2
  fi

  if [[ "${pgm_database}" =~ [${PGM_PGDATABASE_AUTHORIZED_CHARS}]+ ]]; then
    # First set versions constants
    export PGM_PGDBNAME="${pgm_database}"

    # Remove trailing slashes.
    for pgm_pattern in ${!PGMDBPATTERN_*}
    do
      eval pgm_value=\$${pgm_pattern}
      eval ${pgm_pattern/PGMDBPATTERN_/PGM_}=${pgm_value%/}
    done

    return 0
  else
    printf "Wrong database name {pgm_database}\n"
    return 1
  fi
}

function loadDataFromTab()
{
  pgm_set1='.+'
  pgm_set2='.+'
  pgm_set3='.+'

  case $3 in
    1) pgm_set1=$1
       ;;

    2) pgm_set1=$1
       pgm_set2=$2
       ;;

    3) pgm_set1=$1
       pgm_set2=$2
       pgm_set3=$3
       ;;

    *) return 1
       ;;
  esac

  # Check environement
  if [ ! -r ${PGM_PGTAB} ]; then
    return 2
  else
    # Get instance environement
    pgm_line=$(egrep "^[:space:]*${pgm_set1}:${pgm_set2}:${pgm_set3}:[ynYN]" ${PGM_PGTAB})
    if [ $? -ne 0 ]; then
      pgm_line=""
    elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
      pgm_pgline=$(echo "${pgm_pgline}" | head 1)
    fi
    # If nothing found, search with another switch
    if [ -z "${pgm_line}" ]; then
      pgm_line=$(egrep "^[:space:]*${pgm_set1}:${pgm_set3}:${pgm_set2}:[ynYN]" ${PGM_PGTAB})
      if [ $? -ne 0 ]; then
        pgm_line=""
      elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
        pgm_pgline=$(echo "${pgm_pgline}" | head 1)
      fi
    fi    
    # If nothing found, search with another switch
    if [ -z "${pgm_line}" ]; then
      pgm_line=$(egrep "^[:space:]*${pgm_set2}:${pgm_set1}:${pgm_set3}:[ynYN]" ${PGM_PGTAB})
      if [ $? -ne 0 ]; then
        pgm_line=""
      elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
        pgm_pgline=$(echo "${pgm_pgline}" | head 1)
      fi
    fi    
    # If nothing found, search with another switch
    if [ -z "${pgm_line}" ]; then
      pgm_line=$(egrep "^[:space:]*${pgm_set2}:${pgm_set3}:${pgm_set1}:[ynYN]" ${PGM_PGTAB})
      if [ $? -ne 0 ]; then
        pgm_line=""
      elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
        pgm_pgline=$(echo "${pgm_pgline}" | head 1)
      fi
    fi    
    # If nothing found, search with another switch
    if [ -z "${pgm_line}" ]; then
      pgm_line=$(egrep "^[:space:]*${pgm_set3}:${pgm_set1}:${pgm_set2}:[ynYN]" ${PGM_PGTAB})
      if [ $? -ne 0 ]; then
        pgm_line=""
      elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
        pgm_pgline=$(echo "${pgm_pgline}" | head 1)
      fi
    fi    
    # If nothing found, search with another switch
    if [ -z "${pgm_line}" ]; then
      pgm_line=$(egrep "^[:space:]*${pgm_set3}:${pgm_set2}:${pgm_set1}:[ynYN]" ${PGM_PGTAB})
      if [ $? -ne 0 ]; then
        pgm_line=""
      elif [ $(echo "${pgm_pgline}" | wc -l) -gt 1 ]; then
        pgm_pgline=$(echo "${pgm_pgline}" | head 1)
      fi
    fi    


    if [ ! -z "${pgm_line}" ]; then
      pgm_db=$(echo "${pgline}" | cut -d : -f 1)
      pgm_instance=$(echo "${pgline}" | cut -d : -f 2)
      pgm_version=$(echo "${pgline}" | cut -d : -f 3)

      if [ "${pgm_db}" == '*' ] && [ "${pgm_instance}" == '*' ]; then
        setServer ${pgm_version}
        if [ $? -ne 0 ]; then
          return 4
        fi
      elif [ "${pgm_db}" == '*' ]; then
        setInstance ${pgm_version} ${pgm_instance}
        if [ $? -ne 0 ]; then
          return 5
        fi
      else
        setDatabase ${pgm_version} ${pgm_instance} ${pgm_db}
        if [ $? -ne 0 ]; then
          return 6
        fi
      fi
    else
      return 3
    fi
  fi
}
# Nothing should happens after next line
export PGM_PG_INCLUDE="LOADED"
